# Intuition
I wanted to jump to binary search, I need to master this technique.

Takeaways:
- Evaluate the limits: 0 <-> len(n)
- Sort is the biggest time consumption, ask if needed.
- (left < right): --> needs to be < and not <=
- Move 1 by 1, avoid overengeneering.
- As this problem is array associative, validate 0 or <2 elements.
- Python uses the pairs as () and enumarate helps me to iterate. (similar to first and second of c++).
- List has an attribute sort with n log n.


# Approach
I am practicing the two pointers technique.

# Complexity
- Time complexity:
Creating the (value, index) pairs: O(n)
Sorting the array: O(n log n)
Two-pointer search: O(n)
Total: O(n log n)

- Space complexity:
Storing the (value, index) pairs: O(n)
No extra space beyond this (ignoring input/output).
Total: O(n)

# Code
```python3 []
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # Add input validation
        if not nums or len(nums) < 2:
            return []
        
        # Create array of (value, original_index) pairs
        indexed_nums = [(num, i) for i, num in enumerate(nums)]
        
        # Sort by value
        indexed_nums.sort()
        
        left = 0
        right = len(indexed_nums) - 1
        
        while left < right:
            current_sum = indexed_nums[left][0] + indexed_nums[right][0]
            if current_sum == target:
                return [indexed_nums[left][1], indexed_nums[right][1]]
            elif current_sum < target:
                left += 1
            else:
                right -= 1
        
        return []
```